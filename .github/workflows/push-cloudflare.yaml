name: Build

on:
  push:
    branches: [main, uat, release*]
  workflow_dispatch:

jobs:
  build:
    name: Run production build
    runs-on: ubuntu-latest
    env:
      # Pin tool versions to avoid upstream updates breaking CI
      WORKER_BUILD_VERSION: "0.7.1"
      WRANGLER_VERSION: "4.54.0"
      # Web Vault frontend (bw_web_builds) version tag (default pinned; override via GitHub Actions Variables)
      # - Set repository variable BW_WEB_VERSION (e.g. v2025.12.0) to override
      # - Set to "latest" to follow the latest bw_web_builds release
      BW_WEB_VERSION: ${{ vars.BW_WEB_VERSION || 'v2025.12.0' }}

      # Required for wrangler
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js (for npx wrangler)
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Rust toolchain (from rust-toolchain.toml)
        run: |
          set -euo pipefail
          TOOLCHAIN="$(sed -n 's/^channel[[:space:]]*=[[:space:]]*"\([^"]*\)".*$/\1/p' rust-toolchain.toml | head -n 1)"
          if [ -z "$TOOLCHAIN" ]; then
            echo "‚ùå Failed to read toolchain channel from rust-toolchain.toml" >&2
            exit 1
          fi
          echo "Using Rust toolchain: $TOOLCHAIN"
          echo "RUSTUP_TOOLCHAIN=$TOOLCHAIN" >> "$GITHUB_ENV"
          rustup toolchain install "$TOOLCHAIN" --profile minimal --component rustfmt --component clippy --target wasm32-unknown-unknown

      - name: Install lld
        run: sudo apt install -y lld clang gcc llvm

      - name: Install worker-build
        run: |
          set -euo pipefail
          if command -v worker-build &> /dev/null; then
            echo "worker-build already installed: $(worker-build --version || true)"
          fi
          cargo install --locked -q worker-build --version "${WORKER_BUILD_VERSION}"

      - name: Download and extract frontend (bw_web_builds)
        run: |
          set -euo pipefail
          TAG="${BW_WEB_VERSION}"
          if [ "${TAG}" = "latest" ]; then
            TAG="$(curl -s https://api.github.com/repos/dani-garcia/bw_web_builds/releases/latest | jq -r .tag_name)"
          fi

          echo "üì¶ Downloading frontend version: ${TAG}"

          # Download the web vault release
          wget -q "https://github.com/dani-garcia/bw_web_builds/releases/download/${TAG}/bw_web_${TAG}.tar.gz"

          # Extract to public/web-vault
          tar -xzf "bw_web_${TAG}.tar.gz" -C public/

          # bw_web_builds extracts into a web-vault folder (expected)
          if [ ! -d "public/web-vault" ]; then
            echo "‚ùå Expected ./public/web-vault after extracting bw_web_builds" >&2
            ls -la public/ | head -50 || true
            exit 1
          fi

          # Remove large source maps to satisfy Cloudflare static asset per-file limits
          find public/web-vault -type f -name '*.map' -delete

          # Cleanup
          rm -f "bw_web_${TAG}.tar.gz"

          echo "‚úÖ Frontend files extracted to ./public/web-vault"
          ls -la public/web-vault/ | head -20

      - name: Apply web vault overrides (vaultwarden.css)
        run: |
          bash scripts/apply-web-vault-overrides.sh public/web-vault

      - name: Replace D1_DATABASE_ID in wrangler.toml
        run: sed -i "s/\${D1_DATABASE_ID}/${{ secrets.D1_DATABASE_ID }}/g" wrangler.toml

      - name: Enable R2 binding when R2_NAME is provided
        env:
          R2_NAME: ${{ secrets.R2_NAME }}
        run: |
          if [ -n "$R2_NAME" ]; then
            echo "üîß Enabling R2 bucket binding"
            {
              echo ''
              echo '[[r2_buckets]]'
              echo 'binding = "ATTACHMENTS_BUCKET"'
              echo "bucket_name = \"${R2_NAME}\""
            } >> wrangler.toml
          else
            echo "‚è≠Ô∏è R2_NAME not set, skipping R2 binding"
          fi

      - name: Debug D1 response format (optional)
        if: false  # ËÆæÁΩÆ‰∏∫ true Êù•ÂêØÁî®Ë∞ÉËØï
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"
          
          echo "=== Testing wrangler D1 response format ==="
          
          # ÊµãËØïÊü•ËØ¢Âπ∂Êü•ÁúãÂéüÂßãËæìÂá∫
          $WRANGLER d1 execute vault1 --remote --command \
            "SELECT COUNT(*) AS cnt FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_cf_%' AND name NOT IN ('d1_migrations');" \
            --json | tee raw_output.json || true
          
          echo -e "\n=== Testing jq parsing ==="
          cat raw_output.json | jq . || echo "jq failed to parse JSON"

      - name: Bootstrap D1 schema when database is empty
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"

          # ÊñπÊ≥ï1Ôºö‰ΩøÁî®Êõ¥ÂÅ•Â£ÆÁöÑ jq Êü•ËØ¢
          echo "Checking existing tables in D1 database..."
          
          # Â∞ùËØï‰∏çÂêåÁöÑ jq Ëß£ÊûêÊ®°Âºè
          RAW_OUTPUT="$($WRANGLER d1 execute vault1 --remote --command \
            "SELECT COUNT(*) AS cnt FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' AND name NOT LIKE '_cf_%' AND name NOT IN ('d1_migrations');" \
            --json)"
          
          echo "Raw JSON output length: ${#RAW_OUTPUT}"
          
          # Â∞ùËØïËß£ÊûêËæìÂá∫
          TABLE_COUNT=$(echo "$RAW_OUTPUT" | jq -r '
            # Â§ÑÁêÜÂêÑÁßçÂèØËÉΩÁöÑÂìçÂ∫îÊ†ºÂºè
            if . == null then
              0
            elif type == "array" and length > 0 then
              (.[0]?.results?[0]?.cnt // 0)
            elif .result? != null then
              (.result[0]?.results?[0]?.cnt // 0)
            elif .results? != null then
              (.results[0]?.cnt // 0)
            elif .cnt? != null then
              .cnt
            else
              0
            end
          ' 2>/dev/null || echo "0")
          
          # Â¶ÇÊûú jq Â§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî® grep/sed ÊñπÊ≥ï
          if [ "$TABLE_COUNT" = "0" ] || [ -z "$TABLE_COUNT" ]; then
            echo "Falling back to grep/sed method..."
            TABLE_COUNT=$(echo "$RAW_OUTPUT" | grep -o '"cnt":[[:space:]]*[0-9]*' | head -1 | grep -o '[0-9]*' || echo "0")
          fi
          
          # Á°Æ‰øù TABLE_COUNT ÊòØÊúâÊïàÁöÑÊï∞Â≠ó
          if ! [[ "$TABLE_COUNT" =~ ^[0-9]+$ ]]; then
            echo "Warning: Invalid TABLE_COUNT value: '$TABLE_COUNT', defaulting to 0"
            TABLE_COUNT="0"
          fi
          
          echo "Existing app table count: ${TABLE_COUNT}"
          
          if [ "${TABLE_COUNT}" = "0" ]; then
            echo "üÜï Empty D1 database detected; applying sql/schema.sql..."
            
            # Â∫îÁî®Âü∫Á°Ä schema
            $WRANGLER d1 execute vault1 --remote --file sql/schema.sql
            
            echo "‚úÖ Base schema applied successfully"
            
            # ÂàõÂª∫ migrations Ë°®
            echo "üìù Setting up migrations table..."
            $WRANGLER d1 execute vault1 --remote --command "
              CREATE TABLE IF NOT EXISTS d1_migrations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
              );
            "
            
            # Ê†áËÆ∞Áé∞ÊúâËøÅÁßª‰∏∫Â∑≤Â∫îÁî®
            echo "üìù Marking existing migrations as applied..."
            if [ -d "migrations" ] && [ "$(ls -1 migrations/*.sql 2>/dev/null | wc -l)" -gt 0 ]; then
              for f in migrations/*.sql; do
                MIGRATION_NAME="$(basename "${f}")"
                echo "Marking migration as applied: ${MIGRATION_NAME}"
                $WRANGLER d1 execute vault1 --remote --command \
                  "INSERT OR IGNORE INTO d1_migrations (name) VALUES ('${MIGRATION_NAME}');"
              done
            else
              echo "No migration files found in migrations/ directory"
            fi
            
            echo "‚úÖ D1 database bootstrap completed"
          else
            echo "‚è≠Ô∏è D1 already has tables; skipping base schema bootstrap"
          fi

      - name: Apply D1 database migrations
        run: |
          set -euo pipefail
          WRANGLER="npx --yes wrangler@${WRANGLER_VERSION}"

          # Â∫îÁî®ËøÅÁßªÔºåÂ§ÑÁêÜÂèØËÉΩÁöÑÈáçÂ§çÂàóÈîôËØØ
          MAX_RETRIES=5
          RETRY_COUNT=0

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üîÑ Attempting to apply migrations (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
            
            # ÊçïËé∑ËæìÂá∫
            MIGRATION_OUTPUT="$($WRANGLER d1 migrations apply vault1 --remote 2>&1 || true)"
            echo "$MIGRATION_OUTPUT"
            
            # Ê£ÄÊü•ÊòØÂê¶ÊàêÂäü
            if echo "$MIGRATION_OUTPUT" | grep -q "Applying migration" && echo "$MIGRATION_OUTPUT" | grep -q "No migrations to apply\|Successfully applied"; then
              echo "‚úÖ All migrations applied successfully"
              exit 0
            fi
            
            # Ê£ÄÊü•ÊòØÂê¶ÊòØÈáçÂ§çÂàóÈîôËØØ
            if echo "$MIGRATION_OUTPUT" | grep -q "duplicate column name\|column.*already exists"; then
              # ÊèêÂèñÂ§±Ë¥•ÁöÑËøÅÁßªÊñá‰ª∂Âêç
              FAILED_MIGRATION=$(echo "$MIGRATION_OUTPUT" | grep -o "Migration [0-9_]*\.sql" | cut -d' ' -f2 || echo "")
              
              if [ -n "$FAILED_MIGRATION" ]; then
                echo "‚ö†Ô∏è Migration '$FAILED_MIGRATION' failed: column already exists"
                echo "üìù Marking migration as applied and retrying..."
                
                # Á°Æ‰øù migrations Ë°®Â≠òÂú®
                $WRANGLER d1 execute vault1 --remote --command "
                  CREATE TABLE IF NOT EXISTS d1_migrations (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT UNIQUE NOT NULL,
                    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
                  );
                  INSERT OR IGNORE INTO d1_migrations (name) VALUES ('$FAILED_MIGRATION');
                "
                
                RETRY_COUNT=$((RETRY_COUNT + 1))
                echo "üîÅ Retrying remaining migrations..."
                sleep 1  # Áü≠ÊöÇÁ≠âÂæÖ
              else
                echo "‚ùå Could not identify failed migration"
                exit 1
              fi
            else
              echo "‚ùå Migration failed with unexpected error"
              exit 1
            fi
          done

          echo "‚ùå Max retries ($MAX_RETRIES) exceeded"
          exit 1

      - name: Seed global equivalent domains (optional)
        env:
          SEED_GLOBAL_DOMAINS: ${{ vars.SEED_GLOBAL_DOMAINS || 'true' }}
          GLOBAL_DOMAINS_URL: ${{ vars.GLOBAL_DOMAINS_URL }}
        run: |
          set -euo pipefail
          if [ "${SEED_GLOBAL_DOMAINS}" = "false" ]; then
            echo "‚è≠Ô∏è SEED_GLOBAL_DOMAINS=false, skipping"
            exit 0
          fi

          if [ -n "${GLOBAL_DOMAINS_URL:-}" ]; then
            bash scripts/seed-global-domains.sh --db vault1 --remote --wrangler-version "${WRANGLER_VERSION}" --url "${GLOBAL_DOMAINS_URL}"
          else
            bash scripts/seed-global-domains.sh --db vault1 --remote --wrangler-version "${WRANGLER_VERSION}"
          fi

      - uses: cloudflare/wrangler-action@v3
        id: cf
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          wranglerVersion: ${{ env.WRANGLER_VERSION }}
          packageManager: npm
          command: deploy
